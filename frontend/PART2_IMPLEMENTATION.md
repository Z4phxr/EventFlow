# EventFlow Frontend - Part 2/2 Implementation

## Overview
Part 2 extends the frontend to demonstrate Grade 5.0 microservices architecture with RabbitMQ asynchronous communication, making the producer-consumer flow visible in the UI.

## New Features

### 1. Notifications Page (`/notifications`)
**Purpose**: Display notifications generated by the notification-service after consuming RabbitMQ messages.

**Features**:
- Fetches notifications via `GET /api/notifications`
- Displays table with:
  - Type (EVENT_CREATED, EVENT_UPDATED, EVENT_DELETED, USER_REGISTERED, USER_UNREGISTERED)
  - Message content
  - Created timestamp
  - Related Event ID / User ID
- Refresh button for manual updates
- Auto-refresh toggle (every 4 seconds)
- Empty state when no notifications exist
- Color-coded type badges

**Access**: All authenticated users

### 2. Demo Dashboard (`/demo`)
**Purpose**: Demonstrate microservices architecture and async communication for Grade 5.0 defense.

#### A) System Overview Panel
Visual HTML/CSS diagram showing:
- Frontend → API Gateway → 3 microservices (user, event, notification)
- event-service → RabbitMQ → notification-service
- Explanation of event-driven flow

#### B) Live Status Panel
Service health indicators:
- **user-service**: Shows "CONFIGURED" (no safe GET endpoint)
- **event-service**: Pings `GET /api/events` to verify availability
- **notification-service**: Pings `GET /api/notifications` to verify availability
- Last checked timestamp for each service
- Refresh button to re-check health

#### C) Demo Actions Panel
Interactive buttons to prove async flow:

**For Organizers**:
1. **Create Demo Event**: 
   - Creates event via `POST /api/events`
   - Shows event ID
   - Displays "Expected message published to RabbitMQ: event.created"
   - Captures notification count before action

**For Users**:
2. **Register to Demo Event**:
   - Registers via `POST /api/events/{id}/registrations`
   - Can enter event ID manually
   - Displays "Expected message published to RabbitMQ: registration.created"
   - Captures notification count before action

**For All**:
3. **Check Notifications**:
   - Fetches `GET /api/notifications`
   - Compares with count before action
   - Shows number of new notifications
   - Displays success message if new notifications found

**Flow Explanation Panel**: Step-by-step breakdown of the async flow with numbered steps.

**Access**: All authenticated users

### 3. Updated Navigation
- Added "Notifications" link (visible when logged in)
- Added "Demo" link (visible when logged in)
- Maintains existing role-based links

## API Integration

### New Endpoints Added:

```javascript
// Notifications API
notificationsAPI.getAll() 
// GET /api/notifications
// Returns: [{ id, type, message, createdAt, eventId?, userId? }]

// Health Check API
healthAPI.checkEventService()
// GET /api/events?limit=1

healthAPI.checkNotificationService()
// GET /api/notifications?limit=1
```

## File Structure

```
frontend/src/
├── pages/
│   ├── Notifications.jsx      # NEW: Notifications list page
│   └── DemoDashboard.jsx      # NEW: Microservices demo dashboard
├── api.js                     # UPDATED: Added notificationsAPI, healthAPI
├── App.jsx                    # UPDATED: Added /notifications and /demo routes
├── components/
│   └── Navbar.jsx             # UPDATED: Added Notifications and Demo links
└── index.css                  # UPDATED: Added styling for new pages
```

## Expected Backend Response Format

### GET /api/notifications
```json
[
  {
    "id": 1,
    "type": "EVENT_CREATED",
    "message": "New event 'Tech Conference 2026' has been created",
    "createdAt": "2026-01-12T10:30:00",
    "eventId": 5,
    "userId": null
  },
  {
    "id": 2,
    "type": "USER_REGISTERED",
    "message": "User testuser registered for event 'Tech Conference 2026'",
    "createdAt": "2026-01-12T10:35:00",
    "eventId": 5,
    "userId": 3
  }
]
```

### Notification Types
- `EVENT_CREATED` - When organizer creates event
- `EVENT_UPDATED` - When organizer updates event
- `EVENT_DELETED` - When organizer deletes event
- `USER_REGISTERED` - When user registers for event
- `USER_UNREGISTERED` - When user unregisters from event

## Verification Script

### Test Scenario 1: Organizer Creates Event

1. **Login as Organizer**:
   ```
   Navigate to /login
   Username: testorganizer
   Password: password123
   ```

2. **Access Demo Dashboard**:
   ```
   Navigate to /demo
   Verify all 3 sections are visible:
   - System Architecture Overview
   - Service Health Status
   - Demo Actions
   ```

3. **Check Initial Service Health**:
   ```
   Click "Refresh Health Status"
   Verify:
   - user-service: CONFIGURED
   - event-service: OK (green)
   - notification-service: OK (green)
   ```

4. **Create Demo Event**:
   ```
   Click "Create Demo Event" button
   Verify:
   - Success message appears
   - Event ID is shown (e.g., "Demo Event ID: 15")
   - Message shows: "Expected message published to RabbitMQ: event.created"
   ```

5. **Check for New Notification**:
   ```
   Wait 2-3 seconds (for async processing)
   Click "Check Notifications" button
   Verify:
   - Message shows: "Found 1 new notification(s)!"
   ```

6. **View Notifications Page**:
   ```
   Click "Notifications" in navbar
   Verify:
   - Table shows new notification
   - Type badge shows "Event Created" (green)
   - Message contains event title
   - Created timestamp is recent
   - Event ID matches created event
   ```

### Test Scenario 2: User Registers for Event

1. **Logout and Login as User**:
   ```
   Click Logout
   Navigate to /login
   Username: testuser
   Password: password123
   ```

2. **Access Demo Dashboard**:
   ```
   Navigate to /demo
   Verify "Register to Demo Event" card is visible
   ```

3. **Enter Event ID**:
   ```
   In the input field, enter the event ID from Scenario 1 (e.g., 15)
   Verify button text updates: "Register to Event #15"
   ```

4. **Register to Event**:
   ```
   Click "Register to Event #15" button
   Verify:
   - Success message appears
   - Message shows: "Expected message published to RabbitMQ: registration.created"
   ```

5. **Check for New Notification**:
   ```
   Wait 2-3 seconds
   Click "Check Notifications" button
   Verify:
   - Message shows: "Found 1 new notification(s)!"
   ```

6. **View Notifications Page**:
   ```
   Click "Notifications" in navbar
   Verify:
   - Table shows new notification
   - Type badge shows "User Registered" (blue)
   - Message mentions user registration
   - Event ID matches
   - User ID is present
   ```

7. **Test Auto-Refresh**:
   ```
   On /notifications page:
   - Enable "Auto-refresh (4s)" checkbox
   - Wait and observe "Last updated" timestamp changes every 4 seconds
   - Perform another action (e.g., unregister)
   - See new notification appear automatically
   ```

### Test Scenario 3: Full Async Flow Demonstration

This scenario demonstrates the complete flow for Grade 5.0 defense:

1. **Setup**: Login as organizer, open /demo

2. **Action**: Click "Create Demo Event"
   - **Frontend**: Sends `POST /api/events`
   - **Gateway**: Routes to event-service (port 8082)
   - **event-service**: 
     - Saves event to database
     - Publishes `EventCreated` to RabbitMQ exchange
   - **RabbitMQ**: Message sits in `notification.queue`
   - **notification-service**: 
     - Consumes message from queue
     - Persists notification to database
   
3. **Verification**: Click "Check Notifications"
   - **Frontend**: Sends `GET /api/notifications`
   - **Gateway**: Routes to notification-service (port 8083)
   - **notification-service**: Returns notifications from database
   - **Frontend**: Displays count comparison, shows new notifications

4. **Result**: New notification visible in UI, proving end-to-end async flow!

## Architecture Demonstration Points

When presenting for Grade 5.0, use the Demo Dashboard to show:

### 1. Microservices Architecture
- Point to System Overview diagram
- Explain 3 independent services (user, event, notification)
- Show API Gateway as single entry point
- Mention separate databases per service

### 2. Asynchronous Communication
- Point to RabbitMQ in diagram
- Explain: event-service publishes, notification-service consumes
- Emphasize: NO direct HTTP calls between services
- Show: Messages flow through broker, not REST

### 3. Event-Driven Design
- Explain domain events: EventCreated, UserRegistered, etc.
- Show: Actions trigger events, not synchronous updates
- Demonstrate: notification-service reacts to events independently

### 4. Producer-Consumer Flow
- **Producer**: event-service (creates events/registrations)
- **Message Broker**: RabbitMQ (routes messages)
- **Consumer**: notification-service (persists notifications)
- **Proof**: Create event → Check notifications → See result

### 5. Distributed Runtime
- Show Live Status Panel with 3 services
- Mention: Each service runs independently
- Explain: Docker Compose orchestrates all containers
- Show: Services can be scaled independently

## Key UI Features for Demo

### Visual Elements
- ✅ Architecture diagram (HTML/CSS, no images)
- ✅ Service health indicators (OK/FAIL with colors)
- ✅ Action buttons with clear labels
- ✅ Expected RabbitMQ message indicators
- ✅ Notification comparison (before/after counts)
- ✅ Step-by-step flow explanation

### Interactive Elements
- ✅ Create demo event button
- ✅ Register to event button
- ✅ Check notifications button
- ✅ Refresh health status button
- ✅ Auto-refresh toggle
- ✅ Manual refresh button

### Feedback Mechanisms
- ✅ Success/error messages for all actions
- ✅ Loading states (disabled buttons)
- ✅ Result displays (event ID, notification count)
- ✅ Last checked timestamps
- ✅ Color-coded status badges

## Styling Notes

- **No emojis**: All icons removed, replaced with text labels
- **Professional colors**: 
  - Blue (#3498db) for frontend/info
  - Purple (#9b59b6) for gateway
  - Green (#2ecc71) for services
  - Orange (#e67e22) for RabbitMQ
- **Clear visual hierarchy**: Headers, sections, cards
- **Responsive design**: Mobile-friendly layout
- **Accessible**: Good contrast, readable fonts

## Common Issues & Solutions

### Issue: Notifications not appearing
**Solution**: 
1. Check backend logs for RabbitMQ consumer errors
2. Verify notification-service is running
3. Wait 2-3 seconds after action (async processing time)
4. Check RabbitMQ management UI (port 15672) for queued messages

### Issue: Health check shows FAIL
**Solution**:
1. Verify services are running: `docker ps`
2. Check API Gateway logs: `docker logs eventflow-gateway-1`
3. Ensure database migrations ran successfully
4. Check service-specific logs

### Issue: "No safe GET endpoint" for auth service
**Solution**: This is expected. user-service doesn't have a safe GET endpoint that doesn't require specific parameters. Status shows "CONFIGURED" which is correct.

### Issue: Auto-refresh not working
**Solution**:
1. Check browser console for errors
2. Verify checkbox is enabled
3. Check Network tab to see if requests are being made every 4 seconds

## Integration with Backend

### Required Backend Endpoints (Already Exist):
- ✅ `GET /api/notifications` - Returns user's notifications
- ✅ `POST /api/events` - Creates event (publishes to RabbitMQ)
- ✅ `POST /api/events/{id}/registrations` - Registers user (publishes to RabbitMQ)
- ✅ `PUT /api/events/{id}` - Updates event (publishes to RabbitMQ)
- ✅ `DELETE /api/events/{id}` - Deletes event (publishes to RabbitMQ)

### Backend Requirements:
- notification-service must expose `GET /api/notifications` through gateway
- Notifications must include: id, type, message, createdAt, eventId?, userId?
- RabbitMQ consumer must persist notifications to database
- Gateway must route `/api/notifications/**` to notification-service

## Testing Checklist

### Notifications Page
- [ ] Page loads without errors
- [ ] Fetches notifications on mount
- [ ] Displays table with correct columns
- [ ] Shows type badges with correct colors
- [ ] Formats timestamps correctly
- [ ] Shows event/user IDs when present
- [ ] Refresh button works
- [ ] Auto-refresh toggle works
- [ ] Empty state displays correctly
- [ ] Last updated timestamp shows

### Demo Dashboard
- [ ] Page loads for authenticated users
- [ ] System overview diagram displays correctly
- [ ] All 3 service boxes visible
- [ ] RabbitMQ flow diagram clear
- [ ] Health check displays status
- [ ] Refresh health button works
- [ ] Create demo event works (organizer)
- [ ] Shows event ID after creation
- [ ] Register to event works (user)
- [ ] Event ID input works
- [ ] Check notifications button works
- [ ] Shows notification count comparison
- [ ] Flow explanation visible
- [ ] Responsive on mobile

### Navigation
- [ ] Notifications link visible when logged in
- [ ] Demo link visible when logged in
- [ ] Links not visible when logged out
- [ ] Navigation works correctly
- [ ] Active link highlighting

## Next Steps (If Needed)

### Potential Enhancements (Not Required for Part 2):
- WebSocket integration for real-time notifications
- Notification filtering by type
- Mark notifications as read
- Delete notifications
- Notification pagination
- Export notifications to CSV
- More detailed service metrics
- Custom health check endpoints per service
- RabbitMQ queue statistics display

## Summary

Frontend Part 2 successfully implements:
- ✅ Notifications page with auto-refresh
- ✅ Demo dashboard with architecture visualization
- ✅ Service health monitoring
- ✅ Interactive demo actions
- ✅ Producer-consumer flow demonstration
- ✅ Professional styling without emojis
- ✅ Complete integration with backend microservices
- ✅ Grade 5.0 requirement demonstration

**The frontend now clearly demonstrates the microservices architecture, RabbitMQ async communication, and event-driven design required for Grade 5.0!**
